using UnityEngine;
using System.Collections;

[RequireComponent(typeof(CharacterController))]

public class Steer : MonoBehaviour {

	//movement variables - exposed in inspector panel
	
	/// Components & objects 
	private GameManager GM;
	// the SteeringAttributes holds several variables needed for steering
	private SteeringAttributes attr;
	// the Steer component implements the basic steering functions
	private Steer steer;	
	// Each vehicle contains a CharacterController which helps to deal with
	// the relationship between movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController;
	//the target for vehicle to seek/pursue
	
	public float gravity = 20.0f; // keep us grounded
	
	private Vector3 targetPos = Vector3.zero;
	private GameObject player;
	//movement Vectors
	private Vector3 acceleration;	//change in velocity per second
	private Vector3 velocity;		//change in position per second
	private Vector3 location;
	
	//movement mutators
	public Vector3 Velocity 
	{
		get { return velocity; }
		set { velocity = value;}
	}
	public Vector3 Location
	{
		get{ return location;}
	}
	public GameObject Player
	{
		get { return player; }
		set { player = value;}
	}
	
	//tester code
	public int curWP = -1;// = GM.WayPoints[0];
	// Use this for initialization
	void Start () {
		GameObject main = GameObject.Find("MainGO");
		characterController = gameObject.GetComponent<CharacterController> ();	
		attr = main.GetComponent<SteeringAttributes> ();
		GM = main.GetComponent<GameManager>();		
		attr = main.GetComponent<SteeringAttributes> ();

		//get component references
		acceleration = Vector3.zero;
		
		velocity = characterController.transform.forward;		
		location = characterController.transform.position;
	}
	
	// Update is called once per frame
	void Update () {
		//CalcSteeringForce ();
		switchWeights ();
		Vector3 s = Seek (player.transform.position);
		Vector3 f = pathFollow ();

		s *= attr.seekWt;
		f *= attr.pathWt;

		ApplyForce (s);
		ApplyForce (f);
		
		velocity += acceleration * Time.deltaTime;
		velocity.y = 0;	// we are staying in the x/z plane
		velocity = Vector3.ClampMagnitude (velocity, attr.maxSpeed); //similar to limit
		
		//orient the transform to face where we going
		if (velocity != Vector3.zero)
			transform.forward = velocity.normalized;
		
		// keep us grounded
		velocity.y -= gravity;
		
		// the CharacterController moves us subject to physical constraints
		characterController.Move (velocity * Time.deltaTime);
		//reset acceleration for next cycle
		acceleration = Vector3.zero;
		location = transform.position;
	}
	
	//calculate and apply steering forces
	/*private void CalcSteeringForce ()
	{ 
		Vector3 force = Vector3.zero;
		
		/*for (int i=0; i<GM.WayPoints.Count; i++)
		{	
			//force += attr.avoidWt * steer.SeekObstacle (obstacles[i], attr.avoidDist);
		}*/
	/*
		Debug.DrawRay (transform.position, force, Color.cyan);
		*/
	
	//seek target
	//force += attr.seekWt * steer.Seek (target.transform.position);
	//	force += steer.Seek (pathfollow());
	
	//force = Vector3.ClampMagnitude (force, attr.maxForce);
	//ApplyForce(force);
	//}//*/
	
	private void ApplyForce (Vector3 steeringForce)
	{
		acceleration = acceleration + steeringForce;	
	}

	Vector3 getNormalPoint(Vector3 p, Vector3 a, Vector3 b) 
	{
		Vector3 ap = p - a;
		Vector3 ab = b - a;
		
		ab = (ab.normalized) * Vector3.Dot (ap, ab);
		
		Vector3 normal = a + ab;
		return normal;
	}

	Vector3 dv = Vector3.zero; 	// desired velocity, used in calculations

	//Seeks the target
	public Vector3 Seek (Vector3 targetPos)
	{
		//find dv, desired velocity
		dv = targetPos - transform.position;		
		dv = dv.normalized * attr.maxSpeed; 	//scale by maxSpeed
		dv -= characterController.velocity;
		dv.y = 0;								// only steer in the x/z plane
		return dv;
	}

	Vector3 pathFollow() 
	{
		Vector3 predict = characterController.velocity.normalized;
		Vector3 predictLoc = location + predict;
		
		Vector3 normal = Vector3.zero;
		float distance = 1000;
		
		// Loop through all points of path
		//for(int i = 0; i < GM.WayPoints.Count; i++)
		//{
		int first = 0;
		int last = 0;
		
		if(curWP >= 0)
		{
			first = curWP - 1;
			
			if(first == -1)
			{
				first = GM.WayPoints.Count - 1;
			}
			last = (first + 3);
		}
		else
		{
			first = 0;
			last = GM.WayPoints.Count;
		}
		for( int i = first; i < last; i++)
		{
			Vector3 a = GM.WayPoints[i % GM.WayPoints.Count].transform.position;	
			Vector3 b = GM.WayPoints[(i + 1) % GM.WayPoints.Count].transform.position;
			
			Vector3 normalPoint = getNormalPoint(predictLoc, a, b);
			
			Vector3 dir = b - a;
			
			if(normalPoint.x < Mathf.Min(a.x, b.x) || normalPoint.x > Mathf.Max (a.x, b.x) || normalPoint.y < Mathf.Min(a.y, b.y) || normalPoint.y > Mathf.Max (a.y, b.y))
			{
				normalPoint = b;
				a = GM.WayPoints[(i + 1) % GM.WayPoints.Count].transform.position;
				b = GM.WayPoints[(i + 2) % GM.WayPoints.Count].transform.position;
				
				dir = b - a;
			}
			
			float dist  = Vector3.Distance(normalPoint, predictLoc);
			Debug.DrawLine(predictLoc, normalPoint, Color.yellow);
			if(dist < distance)
			{
				distance = dist;
				normal = normalPoint;
				curWP = i % GM.WayPoints.Count;
				
				targetPos = normal + dir;
				//targetPos.Normalize();
				//targetPos *= dist;
				
			}
			
			Debug.DrawLine (transform.position, targetPos, Color.cyan);
			Debug.DrawLine(predictLoc, transform.position, Color.red);
			//Debug.DrawLine(predictLoc, nextPoint, Color.yellow);
		}
		if(distance > 0.5f)
		{			
			return Seek(targetPos);
		}
		else
		{
			return Vector3.zero;	
		}
	}

	//uncomment if we will use obstacles for enemy to avoid
	/*
	public Vector3 AvoidObstacle (GameObject obst, float safeDistance)
	{ 
		dv = Vector3.zero;
		float obRadius = obst.GetComponent<ObstacleScript> ().Radius;
		
		//vector from vehicle to center of obstacle
		Vector3 vecToCenter = obst.transform.position - transform.position;
		//eliminate y component so we have a 2D vector in the x, z plane
		vecToCenter.y = 0;
		float dist = vecToCenter.magnitude;
		
		// if too far to worry about, out of here
		if (dist > safeDistance + obRadius + attr.radius)
			return Vector3.zero;
		
		//if behind us, out of here
		if (Vector3.Dot (vecToCenter, transform.forward) < 0)
			return Vector3.zero;
		
		float rightDotVTC = Vector3.Dot (vecToCenter, transform.right);
		
		//if we can pass safely, out of here
		if (Mathf.Abs (rightDotVTC) > attr.radius + obRadius)
			return Vector3.zero;
		
		//obstacle on right so we steer to left
		if (rightDotVTC > 0)
			dv += transform.right * -attr.maxSpeed * safeDistance / dist;
		else
			//obstacle on left so we steer to right
			dv += transform.right * attr.maxSpeed * safeDistance / dist;
		
		return dv;	
	}
	*/
	public void switchWeights()
	{
		var dist = Vector3.Distance(player.transform.position, transform.position);
		Debug.Log(dist); 

		if(dist < 15.0f)
		{
			attr.seekWt = 80.0f;
			attr.pathWt = 0.0f;
		}
		else if(dist < 25.0f)
		{
			attr.seekWt = 40.0f;
			attr.pathWt = 2.0f;
		}	
		else
		{
			attr.seekWt = 2.0f;
			attr.pathWt = 40.0f;
		}
	}

}
