using UnityEngine;
using System.Collections;

public class SteeringVehicle : MonoBehaviour {
	//movement variables - exposed in inspector panel

	/// Components & objects 
	private GameManager GM;
	// the SteeringAttributes holds several variables needed for steering
	private SteeringAttributes attr;
	// the Steer component implements the basic steering functions
	private Steer steer;	
	// Each vehicle contains a CharacterController which helps to deal with
	// the relationship between movement initiated by the character and the forces
	// generated by contact with the terrain & other game objects.
	private CharacterController characterController;
	//the target for vehicle to seek/pursue
	
	public float gravity = 20.0f; // keep us grounded

	private Vector3 targetPos = Vector3.zero;

	//movement Vectors
	private Vector3 acceleration;	//change in velocity per second
	private Vector3 velocity;		//change in position per second
	private Vector3 location;

	//movement mutators
	public Vector3 Velocity 
	{
		get { return velocity; }
		set { velocity = value;}
	}
	public Vector3 Location
	{
		get{ return location;}
	}


	//tester code
	public int curWP = -1;// = GM.WayPoints[0];
	// Use this for initialization
	void Start () {
		//get component references
		characterController = gameObject.GetComponent<CharacterController> ();
		steer = gameObject.GetComponent<Steer> (); //gets reference to the steer
		GameObject main = GameObject.Find("MainGO");
		attr = main.GetComponent<SteeringAttributes> ();
		
		GM = main.GetComponent<GameManager>();
		acceleration = Vector3.zero;

		velocity = characterController.transform.forward;		
		location = characterController.transform.position;
	}
	
	// Update is called once per frame
	void Update () {
		//CalcSteeringForce ();
		Vector3 f = pathFollow ();

		ApplyForce (f);

		velocity += acceleration * Time.deltaTime;
		velocity.y = 0;	// we are staying in the x/z plane
		velocity = Vector3.ClampMagnitude (velocity, attr.maxSpeed); //similar to limit
		
		//orient the transform to face where we going
		if (velocity != Vector3.zero)
			transform.forward = velocity.normalized;
		
		// keep us grounded
		velocity.y -= gravity;
		
		// the CharacterController moves us subject to physical constraints
		characterController.Move (velocity * Time.deltaTime);
		//reset acceleration for next cycle
		acceleration = Vector3.zero;
		location = transform.position;
	}

	//calculate and apply steering forces
	/*private void CalcSteeringForce ()
	{ 
		Vector3 force = Vector3.zero;
		
		/*for (int i=0; i<GM.WayPoints.Count; i++)
		{	
			//force += attr.avoidWt * steer.SeekObstacle (obstacles[i], attr.avoidDist);
		}*/
		/*
		Debug.DrawRay (transform.position, force, Color.cyan);
		*/
		
		//seek target
		//force += attr.seekWt * steer.Seek (target.transform.position);
	//	force += steer.Seek (pathfollow());
		
		//force = Vector3.ClampMagnitude (force, attr.maxForce);
		//ApplyForce(force);
	//}//*/

	private void ApplyForce (Vector3 steeringForce)
	{
		acceleration = acceleration + steeringForce;	
	}

	
	Vector3 pathFollow() 
	{
		Vector3 predict = characterController.velocity.normalized;
		Vector3 predictLoc = location + predict;
		
		Vector3 normal = Vector3.zero;
		float distance = 1000;
	
		// Loop through all points of path
		//for(int i = 0; i < GM.WayPoints.Count; i++)
		//{
		int first = 0;
		int last = 0;
		
		if(curWP >= 0)
		{
			first = curWP - 1;
			
			if(first == -1)
			{
				first = GM.WayPoints.Count - 1;
			}
			last = (first + 3);
		}
		else
		{
			first = 0;
			last = GM.WayPoints.Count;
		}
		for( int i = first; i < last; i++)
		{
			Vector3 a = GM.WayPoints[i % GM.WayPoints.Count].transform.position;	
			Vector3 b = GM.WayPoints[(i + 1) % GM.WayPoints.Count].transform.position;
			
			Vector3 normalPoint = getNormalPoint(predictLoc, a, b);
			
			Vector3 dir = b - a;
			
			if(normalPoint.x < Mathf.Min(a.x, b.x) || normalPoint.x > Mathf.Max (a.x, b.x) || normalPoint.y < Mathf.Min(a.y, b.y) || normalPoint.y > Mathf.Max (a.y, b.y))
			{
				normalPoint = b;
				a = GM.WayPoints[(i + 1) % GM.WayPoints.Count].transform.position;
				b = GM.WayPoints[(i + 2) % GM.WayPoints.Count].transform.position;
				
				dir = b - a;
			}
			
			float dist  = Vector3.Distance(normalPoint, predictLoc);
			Debug.DrawLine(predictLoc, normalPoint, Color.yellow);
			if(dist < distance)
			{
				distance = dist;
				normal = normalPoint;
				curWP = i % GM.WayPoints.Count;
				
				targetPos = normal + dir;
				//targetPos.Normalize();
				//targetPos *= dist;
				
			}
			
			Debug.DrawLine (transform.position, targetPos, Color.cyan);
			Debug.DrawLine(predictLoc, transform.position, Color.red);
			//Debug.DrawLine(predictLoc, nextPoint, Color.yellow);
		}
		if(distance > 0.5f)
		{			
			return steer.Seek(targetPos);
		}
		else
		{
			return Vector3.zero;	
		}
		/*Vector3 predict = characterController.velocity.normalized;
		Vector3 predictLoc = location + predict;

		float distance = 5000000;
		// Loop through all points of path
	
		Vector3 nextPoint = Vector3.zero;
		for (int i = 0; i < GM.WayPoints.Count; i++)
		{
			Vector3 a = GM.WayPoints[i % GM.WayPoints.Count].transform.position;	
			Vector3 b = GM.WayPoints[(i + 1) % GM.WayPoints.Count].transform.position;
			
			Vector3 normalPoint = getNormalPoint(predictLoc, a, b);			
			Vector3 dir = b - a;


			if (normalPoint.x < Mathf.Min(a.x, b.x) || normalPoint.x > Mathf.Max(a.x, b.x) 
			   || normalPoint.y < Mathf.Min(a.y, b.y) || normalPoint.y > Mathf.Max(a.y, b.y)) 
			{
				normalPoint = b;
				a = GM.WayPoints[(i + 1) % GM.WayPoints.Count].transform.position;
				b = GM.WayPoints[(i + 2) % GM.WayPoints.Count].transform.position;

				dir = b - a;
			}	

			float dist = Vector3.Distance(predictLoc,normalPoint);
			if(dist < distance)
			{
				distance = dist;
				dir = dir.normalized;
				//dir /= 25;
				targetPos = normalPoint + dir;
				nextPoint = b;			
				
				Debug.DrawLine(predictLoc, normalPoint, Color.white);
				Debug.DrawLine (transform.position, dir, Color.green);
			}
			

		}
		Debug.DrawLine (transform.position, targetPos, Color.cyan);
		Debug.DrawLine(predictLoc, transform.position, Color.red);
		Debug.DrawLine(predictLoc, nextPoint, Color.yellow);
		if (distance > 0.2f) 
		{
			return steer.Seek(targetPos);
		}
		else
		{
			return Vector3.zero;
		}*/
	}

	Vector3 getNormalPoint(Vector3 p, Vector3 a, Vector3 b) 
	{
		Vector3 ap = p - a;
		Vector3 ab = b - a;
		
		ab = (ab.normalized) * Vector3.Dot (ap, ab);
		
		Vector3 normal = a + ab;
		return normal;
	}
}
